# 动态规划

## T1：购物单

![image-20231127212725692](C:\Users\57873\AppData\Roaming\Typora\typora-user-images\image-20231127212725692.png)

![image-20231127212755767](C:\Users\57873\AppData\Roaming\Typora\typora-user-images\image-20231127212755767.png)

### 关键点

状态：dp\[i][j]为最大使用金额i时有j件物品可选择时的最大价值；

转移方程：当前最大价值=max(不买这个物品（买前一个物品）的价值，不买前一个物品(退钱)买这个物品的价值)

### 解法

```python
money, number = list(map(int, input().strip().split()))
money = money // 10
main = [[[0, 0], [0, 0], [0, 0]] for _ in range(number + 2)]  # 依次存放第一个主件和它的附件
for i in range(1, 1 + number):
    v, p, q = list(map(int, input().strip().split()))
    if q == 0:  # 主件
        main[i][0] = [v // 10, v * p]
    else:
        if main[q][1][0] == 0:
            main[q][1] = [v // 10, v * p]
        else:
            main[q][2] = [v // 10, v * p]
main = [i for i in main if i[0][0] != 0]  # 去掉编号是空的主件
dp = [[0 for i in range(1 + money)] for j in range(1 + len(main))]
for num in range(1, 1 + len(main)):
    for mon in range(1 + money):
        dp[num][mon] = dp[num - 1][mon]  # 当前物品继承上一个物品的最大价值
        (p1, v1), (p2, v2), (p3, v3) = main[num - 1]
        # 不买这个物品（买前一个物品） 和 不买前一个物品买这个物品的最大值
        if mon >= p1 + p2 + p3:  # 这里必须是dp[num][mon]不能是dp[num-1][mon]，因为这个值是在每个if更新的
            dp[num][mon] = max(dp[num][mon], dp[num - 1][mon - p1 - p2 - p3] + v1 + v2 + v3)
        if mon >= p1 + p3:
            dp[num][mon] = max(dp[num][mon], dp[num - 1][mon - p1 - p3] + v1 + v3)
        if mon >= p1 + p2:
            dp[num][mon] = max(dp[num][mon], dp[num - 1][mon - p1 - p2] + v1 + v2)
        if mon >= p1:
            dp[num][mon] = max(dp[num][mon], dp[num - 1][mon - p1] + v1)

print(dp[-1][-1])
```



## T2：合唱队

![image-20231127214547975](C:\Users\57873\AppData\Roaming\Typora\typora-user-images\image-20231127214547975.png)

### 关键点

合唱队最多人数实质是从左往右和从右往左的每个位置最长递增子序列个数的和的最大值。

状态：dp[i]为第i个位置的最长递增子序列个数。

转移方程：当前位置最长递增子序列为=当前位置之前位置里，小于当前位置的最大值，它的子序列个数+1

### 解法

```python
def left_to_right_max_count(ls):
    """
    找出从左往右每个位置左侧最长递增子序列元素数量。
    1、循环列表每个元素i。
    2、循环列表当前元素的前面的元素j。
    3、如果当前元素i比前面的元素j大，且dp[i]较小，则dp更新当前元素i位置的数量为j元素数量+1
    :param ls:
    :return:
    """
    count = len(ls)
    dp = [1 for _ in range(count)]
    for i in range(0, len(ls)):
        for j in range(0, i):
            if ls[i] > ls[j] and dp[i] <= dp[j]:  # 注意and后面进行判断再赋值速度更快
                dp[i] = dp[j] + 1
    return dp

n = int(input())
hight_ls = list(map(int, input().split(' ')))
left = left_to_right_max_count(hight_ls)
right = left_to_right_max_count(hight_ls[::-1])[::-1]
total = [left[i] + right[i] - 1 for i in range(len(left))]
print(len(hight_ls) - max(total))
```

### 进阶

```python
def left_to_right_max_count2(in_arr):
    """
    1.先取出列表第一个元素放在待定的最长递增子序列列表里，再循环其他元素，
    2.如果i大于最长递增子序列就添加到其最后,当前位置的最长递增子序列数量为列表长度
    3.如果i小于就把i替换掉最长递增子序列比它大的第一个数，当前位置的最长递增子序列数量和前一个一致
    :param in_arr:
    :return:
    """
    longest = [1] * len(in_arr)
    result = [in_arr[0]]
    arr_ls = list(enumerate(in_arr, 0))
    for idx, value in arr_ls[1:]:
        if value > result[-1]:
            result.append(value)
            longest[idx] = len(result)
        else:
            idx = bisect.bisect_left(result, value)
            result[idx] = value
            longest[idx] = longest[idx - 1]
    return longest

n = int(input())
hight_ls = list(map(int, input().split(' ')))
left = left_to_right_max_count2(hight_ls)
right = left_to_right_max_count2(hight_ls[::-1])[::-1]
total = [left[i] + right[i] - 1 for i in range(len(left))]
print(len(hight_ls) - max(total))
```

## T3：素数伴侣

![image-20231127215641532](C:\Users\57873\AppData\Roaming\Typora\typora-user-images\image-20231127215641532.png)

### 关键点

和为素数必为偶数+奇数；将输入分为偶数和奇数；提前好计算奇数和偶数所有组合能否构成素数，避免循环中重复计算；用匈牙利算法求最大匹配

1、遍历偶数，寻找可以组成素数伴侣的奇数。

2、给奇数创建访问列表，确保当前偶数对每个奇数只会访问一遍。

3、如该偶数找到且奇数未被访问。如未被匹配，则匹配。如奇数已匹配，则给被匹配的偶数重新递归找一个。

### 解法

```python
def fun2():
    def is_prime(_value):
        if _value == 1:
            return False
        for _i in range(2, 1 + int(_value ** 0.5)):
            if _value % _i == 0:
                return False
        return True

    # 遍历每一个左边节点，给它找一个右边节点
    def find(i, _left_visit_right):
        for j, right in enumerate(right_lis):  # 遍历右
            if matchable[i][j] and _left_visit_right[j] is False:  # 如果左右能匹配,且没访问过
                _left_visit_right[j] = True
                if match_dict.get(j) is None:  # 右边没有匹配
                    match_dict[j] = i  # 给右边匹配左边
                    return True
                elif find(match_dict.get(j), _left_visit_right[::]):  # 右边已经匹配上了左某，试着给左某的再找过一个
                    match_dict[j] = i  # 如果能给左某找到，则右现匹配左现
                    return True
        return False

    n = input()
    arr = list(map(int, input().split()))
    left_lis = [i for i in arr if i % 2 == 0]  # 二分图左边
    right_lis = [i for i in arr if i % 2 != 0]  # 二分图右边
    matchable = [[is_prime(i + j) for j in right_lis] for i in left_lis]  # 二分图里所有可能的路径能否匹配的结果
    match_dict = dict()
    for i, left in enumerate(left_lis):
        left_visit_right = [False for j in right_lis]  # 每一个左边保存一个它右边是否访问列表,必须在此处初始化。每次递归都是新开始
        find(i, left_visit_right)
    print(len(match_dict))


fun2()
```

## T4：最长回文子串

![image-20231127222456713](C:\Users\57873\AppData\Roaming\Typora\typora-user-images\image-20231127222456713.png)

### 关键点

遍历所有可能的子串长度，遍历字符串，不断规划各个长度的i到j子串是否回文。

状态：dp\[i][j]表示从索引i到j的子串是否回文。

转移方程：i到j是否回文=(i到j长度小于等于2 or i+1到j-1是否回文) and i位置是否等于j位置

### 解法

```python
def longest_palindrome(s):
    # 如果字符串长度为0，返回0
    if len(s) == 0:
        return 0
    # 获取字符串长度
    n = len(s)
    # 初始化最长回文子串长度为0
    longest_len = 0
    # 创建一个二维数组，用于存储每个可能的子串是否是回文
    dp = [[False] * n for _ in range(n)]
    # 遍历所有可能的子串长度
    for length in range(1, n + 1):
        # 对每个子串进行检查
        for start in range(n):
            # 计算子串的结束位置
            end = start + length - 1
            # 如果结束位置超过字符串长度，跳出循环
            if end >= n:
                break
            # 判断子串是否是回文
            dp[start][end] = (length == 1 or length == 2 or dp[start + 1][end - 1]) and s[start] == s[end]
            # 如果子串是回文，并且长度大于当前最长回文子串长度，更新最长回文子串长度
            if dp[start][end] and length > longest_len:
                longest_len = length
    # 返回最长回文子串长度
    return longest_len
```

## T5：统计每个月兔子个数

![image-20231127223617151](C:\Users\57873\AppData\Roaming\Typora\typora-user-images\image-20231127223617151.png)

### 关键点

状态：dp[i]为第i个月兔子数量，前两个月数量为1，dp[0]=dp[1]=dp[2]=1。

转移方程：dp[i] = dp[i-1] + dp[i-2]，i月为上个月的兔子 + 上上个月的兔子数量(会再生一个)

### 解法

```python
def fun():
    n = int(input())
    dp = [0 for _ in range(n+1)]  # 第n个月的兔子数量
    dp[0] = dp[1] = dp[2] = 1  # 0月不算 前2个月兔子数量是1
    for i in range(3, 1+n):  # 从第3个月开始计算
        dp[i] = dp[i-1] + dp[i-2]
    print(dp[n])


fun()
```

## T6：计算字符串的最小编辑距离

![image-20231127225839681](C:\Users\57873\AppData\Roaming\Typora\typora-user-images\image-20231127225839681.png)

### 关键点

状态：dp\[i][j]为字符串s1的前i位和字符串s2的前j位的最小编辑距离，i或j为0时最小编辑距离为另一个字符串的长度。

转移方程：s1少一位编辑到s2和s2少一位编辑到s1的距离+1 和 s1与s2都少一位时加s1[i]和s2[j]是否不相等；

dp\[i][j] = min(dp\[i-1][j] + 1, dp\[i][j-1] + 1, dp\[i-1][j-1] + (s1[i-1] != s2[j-1]))

### 解法

```python
def fun():
    n = input()
    m = input()
    dp = [[0 for i in range(len(m)+1)] for j in range(len(n)+1)]  # i和j位时的编辑距离，因为有0位，所以要+1
    for i in range(len(m)+1):  # 给默认值当一个字符串是空串时，编辑距离就是另一个字符串的长度
        dp[0][i] = i
    for i in range(len(n)+1):  # 给默认值当一个字符串是空串时，编辑距离就是另一个字符串的长度
        dp[i][0] = i
    for i in range(1, len(n)+1):  # 因为0字符的时候已经有默认值了，所以从1个字符开始遍历
        for j in range(1, len(m)+1):
            # 有i个或者j个字符的时候对应的是字符串索引是i-1或者j-1
            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + (n[i-1] != m[j-1]))
    print(dp[-1][-1])


fun()
```

## T7：盘子分苹果的分法

![image-20231127230955217](C:\Users\57873\AppData\Roaming\Typora\typora-user-images\image-20231127230955217.png)

### 关键点

状态：dp\[i][j]为盘子i个苹果j个时的分法。

转移方程：

盘子多，苹果少的情况：i个盘子和i-1个盘子是一样的次数。dp\[i][j] = dp\[i - 1][j]。

盘子和苹果相等的情况：等于少一个盘子的次数+1(多一个盘子多一种次数)。dp\[i][j] = dp\[i - 1][j] + 1。

盘子少，苹果多的情况：等于空一个盘子的次数+不空盘子的次数(不空盘子时，每个盘子必有一个，为多余苹果放置的次数)。 dp\[i][j] = dp\[i - 1][j] + dp\[i][j - i]。

### 解法

```python
def fun_dp():
    apple, dish = list(map(int, input().split(' ')))
    dp = [[0 for _ in range(apple + 1)] for _ in range(dish + 1)]  # 初始化dp数组
    for i in range(dish + 1):
        dp[i][0] = 1  # 0个苹果的放法只有1种
    for i in range(1, dish + 1):
        for j in range(1, apple + 1):
            if j < i:  # 盘子多 苹果少
                dp[i][j] = dp[i - 1][j]
            elif i == j:  # 盘子相等苹果，等于少一个盘子的放法+多一个盘子多一种放法
                dp[i][j] = dp[i - 1][j] + 1
            else:  # 盘子少 苹果多
                dp[i][j] = dp[i - 1][j] + dp[i][j - i]  # 盘子空着的，加盘子不空，每个盘子放一个，多余的果放盘子的方法数
    print(dp[-1][-1])
```

## T8：求最长公共子串

![image-20231127232649727](C:\Users\57873\AppData\Roaming\Typora\typora-user-images\image-20231127232649727.png)

### 关键点

状态：dp\[i][j]为s1到i位和s2到j位的最长公共子串长度。

转移方程：s1[i]等于s2[j]时，如果是s1或s2开头，那么dp\[i][j]为1，否则dp\[i][j]为dp\[i-1][j-1]+1。

### 解法

```python
def fun_dp():
    s1, s2 = input(), input()
    s1, s2 = (s1, s2) if len(s1) < len(s2) else (s2, s1)  # s1是短的
    dp = [[0 for _ in s2] for _ in s1]  # s1的i位和s2的j位时的最大公共子串长度
    max_len, max_com_sub_s = 0, ''
    for i in range(0, len(s1)):  # 遍历s1的每个位置
        for j in range(0, len(s2)):  # 遍历s2的每个位置
            if s1[i] == s2[j]:  # 当前位置相等时，
                if i == 0 or j == 0:  # 如果是开头，那自然是1
                    dp[i][j] = 1
                else:   # 动态转移方程为s1 s2上一位的dp值+1
                    dp[i][j] = dp[i-1][j-1] + 1
                if dp[i][j] > max_len:  # 更新最大值，因为最大值不是dp[-1][-1]
                    max_len = dp[i][j]
                    max_com_sub_s = s2[j-max_len+1:j+1]
    print(max_com_sub_s)
```











# 

# 深度优先搜索

## T1：迷宫问题

![image-20231127224135712](C:\Users\57873\AppData\Roaming\Typora\typora-user-images\image-20231127224135712.png)

![image-20231127224204676](C:\Users\57873\AppData\Roaming\Typora\typora-user-images\image-20231127224204676.png)

### 关键点

递归搜索每个位置x,y能通行的各个位置，每次路过位置标记为已访问，如最后无路可走则返回False，回退到上一个能通行的支路口。

### 解法

```python
def fun():
    def dfs(x, y):
        visit[x][y] = True
        if x == n - 1 and y == m - 1:  # 找到了迷宫出口
            maze_path.append((x, y))
            return True
        passable = [True, True, True, True]  # 上下左右是否可以通行
        if x == 0:  # 第一行
            passable[0] = False
        if x == n - 1:  # 最后一行
            passable[1] = False
        if y == 0:  # 第一列
            passable[2] = False
        if y == m - 1:  # 最后一列
            passable[3] = False
        if passable[0] and maze[x - 1][y] == '0' and (visit[x - 1][y] is False):  # 往上可行
            if dfs(x - 1, y):
                maze_path.append((x, y))
                return True
        if passable[1] and maze[x + 1][y] == '0' and (visit[x + 1][y] is False):  # 往下可行
            if dfs(x + 1, y):
                maze_path.append((x, y))
                return True
        if passable[2] and maze[x][y - 1] == '0' and (visit[x][y - 1] is False):  # 往左可行
            if dfs(x, y - 1):
                maze_path.append((x, y))
                return True
        if passable[3] and maze[x][y + 1] == '0' and (visit[x][y + 1] is False):  # 往右可行
            if dfs(x, y + 1):
                maze_path.append((x, y))
                return True
        return False

    n, m = list(map(int, input().split(' ')))  # n行， m列
    maze = [input().split(' ') for _ in range(n)]
    maze_path = []
    visit = [[False for _ in range(m)] for _ in range(n)]  # 当前点是否走过
    dfs(0, 0)
    maze_path = maze_path[::-1]  # 倒放
    for path in maze_path:
        print(f'({path[0]},{path[1]})')


fun()
```

## T2：求数独

![image-20231127224820139](C:\Users\57873\AppData\Roaming\Typora\typora-user-images\image-20231127224820139.png)

![image-20231127224837125](C:\Users\57873\AppData\Roaming\Typora\typora-user-images\image-20231127224837125.png)

### 关键点

遍历所有格子，当前格子有值则跳过。当前格子是空的则求出当前格子当前数独棋盘的所有合法值，遍历所有合法值，每次遍历时dfs下一个格子。如果最后没有合法值了，则返回False，同时将上一步填入的值回溯为0。

### 解法

```python
def fun():
    def find_legal_value(x, y):
        # 查找当前坐标点的合法可填值
        x_axis = set(board[x])
        y_axis = {board[i][y] for i in range(9)}
        sub_board = {board[_x][_y] for _x in [x - x % 3, x - x % 3 + 1, x - x % 3 + 2] for _y in
                     [y - y % 3, y - y % 3 + 1, y - y % 3 + 2]}
        legal_value = set(range(1, 10)) - x_axis - y_axis - sub_board
        if legal_value:
            return legal_value
        else:
            return False

    # 从0,0开始，遍历它的所有合法取值，即行列九宫格都不包含的数字
    def dfs(x, y):
        # 如果已经遍历到了最后一个(8,8),则返回True
        if x == 8 and y == 8:
            value = find_legal_value(8, 8)
            # 最后一个格子为空则填入
            if value:
                for i in value:
                    board[8][8] = i
            return True
        # 超出换行
        y = y + 1 if x == 9 else y
        x = x % 9
        # 找下一个为0的格子
        while board[x][y] != 0:
            x += 1
            # 超出换行
            y = y + 1 if x == 9 else y
            x = x % 9
            if x == 8 and y == 8:
                value = find_legal_value(8, 8)
                # 最后一个格子为空则填入
                if value:
                    for i in value:
                        board[8][8] = i
                return True
        # 检查当前格子是否可以填入
        legal_value = find_legal_value(x, y)
        if legal_value:
            # 可以填入则遍历所有可以填入的值
            for value in legal_value:
                board[x][y] = value  # 填入
                if dfs(x + 1, y):  # dfs下一个
                    return True
                else:
                    board[x][y] = 0  # 回溯
        else:  # 不可以则返回False
            return False

    board = [list(map(int, input().split(' '))) for _ in range(9)]
    dfs(0, 0)
    for i in board:
        i = list(map(str, i))
        print(' '.join(i))
```

## T3：盘子分苹果的分法

![image-20231127230955217](C:\Users\57873\AppData\Roaming\Typora\typora-user-images\image-20231127230955217.png)

### 关键点

递归i个苹果和j个碟子时的次数，分3种情况。

盘子多，苹果少的情况：i个盘子和i-1个盘子是一样的次数。

盘子和苹果相等的情况：等于少一个盘子的次数+1(多一个盘子多一种次数)。

盘子少，苹果多的情况：等于空一个盘子的次数+不空盘子的次数(不空盘子时，每个盘子必有一个，为多余苹果放置的次数)。

### 解法

```python
def fun_dfs():
    def dfs(apple, dish):
        if apple == 1 or dish == 1:
            return 1
        elif apple < dish:  # 苹果数量少
            return dfs(apple, dish - 1)
        elif apple == dish:
            return dfs(apple, dish - 1) + 1  # 相等时，等于少一个盘子的时候 + 多一个盘子的时候多1个选择
        elif apple > dish:
            # 空一个盘子 + (不空时必有apple - dish要放在dish个里)
            return dfs(apple, dish - 1) + dfs(apple - dish, dish)

    _apple, _dish = list(map(int, input().split(' ')))
    ret = dfs(_apple, _dish)
    print(ret)
```

## T4：求是否能计算为24点

![image-20231127233311337](C:\Users\57873\AppData\Roaming\Typora\typora-user-images\image-20231127233311337.png)

### 关键点

由于不限顺序，所以要枚举所有顺序组合；

递归一种组合n，和当前的值value，以及递归到n的位置i，依次递归加减乘除4种情况，如果i到了最后且不等于24则返回False，否则返回True。

注意存在(1+1) x (10+2)的情况，需要单独递归。

### 解法

```python
from itertools import permutations


def fun():
    num = list(map(int, input().split(' ')))

    def dfs(n, value, i):
        if i == 3:  # 当前列表已经递归完
            return True if value == 24 else False  # 当前递归计算的值是不是24
        # 递归当前列表的每一种运算
        if dfs(n, value + n[i + 1], i + 1) or dfs(n, value - n[i + 1], i + 1) or dfs(n, value * n[i + 1], i + 1) or dfs(n, value / n[i + 1], i + 1):
            return True
        elif i == 1 and (dfs(n, value * (n[i+1] + n[i+2]), i+2) or dfs(n, value * (n[i+1] - n[i+2]), i+2)):  # 后两位是括号
            return True
        elif i == 1 and ((n[i+1] - n[i+2] != 0 and dfs(n, value / (n[i+1] - n[i+2]), i+2)) or dfs(n, value / (n[i+1] + n[i+2]), i+2)):  # 后两位是括号
            return True
        return False
    # 循环输入的4位数的排列
    for _n in list(permutations(num)):
        if dfs(_n, _n[0], 0):  # 只要有一种满足则停止
            print('true')
            return
    print('false')


fun()
```

## T5：字符串的通配符

![image-20231127234316204](C:\Users\57873\AppData\Roaming\Typora\typora-user-images\image-20231127234316204.png)

![image-20231127234338662](C:\Users\57873\AppData\Roaming\Typora\typora-user-images\image-20231127234338662.png)

### 关键点

递归两个字符串s和rule:

1、如果两者0位相等则递归s[1:]和rule[1:];

2、否则如果两者0位不相等但是rule是?且s是数字字母，则双方递归下一位；

3、否则如果0位rule是*则分为递归s匹配和s不匹配的情况。s匹配则递归s下一位，rule不动；s不匹配则递归s不动rule下一位。

4、双方都刚好结束返回True，或者s结束rule只剩下*也返回True，否则都是False。

### 解法

```python
def fun2():
    def dfs(s: str, rule: str):
        if (s, rule) in visit:  # 当前组合已经访问过了就抬走
            return False
        visit.append((s, rule))
        if s == '' and rule == '':  # s完毕且rule刚好完毕，ok
            return True
        elif s != '' and rule == '':  # s未完毕，rule完毕，gg
            return False
        elif s == '' and rule != '':  # s完毕，rule未完毕，看rule是否只剩下*
            if rule.replace('*', '') == '':  # 只剩下*，ok
                return True
            else:  # 还有其他rule值，gg
                return False
        # 直接就相等抬走下一位
        if s[0] == rule[0]:
            return dfs(s[1:], rule[1:])
        else:
            # 是？的时候必须要是数字字母才进入匹配
            if rule[0] == '?' and s[0].isalnum():
                return dfs(s[1:], rule[1:])
            # 是*的时候分进入和跳过
            elif rule[0] == '*':
                # * 匹配，s往后移
                if s[0].isalnum() and dfs(s[1:], rule):
                    return True
                # * 不匹配， rule往后移
                elif dfs(s, rule[1:]):
                    return True
                else:
                    return False

    rule, s, visit = input().lower(), input().lower(), []
    print('true' if dfs(s, rule) else 'false')

fun2()
```



# 栈

## T1：矩阵乘法计算量计算

![image-20231127233911976](C:\Users\57873\AppData\Roaming\Typora\typora-user-images\image-20231127233911976.png)

### 关键点

遍历计算法则字符串，如果不是右括号则入栈，遇到右括号则出栈栈顶元素2个，进行计算后再入栈。

### 解法

```python
def fun():
    n = int(input())
    arr = [list(map(int, input().split())) for i in range(n)]
    order, res = [], 0
    f = input()
    for i in f:
        if i.isalpha():
            order.append(arr[ord(i) - 65])  # 将字母转换成第几个矩阵的处理信息
        elif i == ')' and len(order) >= 2:  # 读到右括号就处理最近的两个矩阵相乘的结果
            b = order.pop()
            a = order.pop()
            res += a[1] * b[1] * a[0]  # 累计到res中
            order.append([a[0], b[1]])
    print(res)


fun()
```



# 数学

## T1：质数因子

![image-20231127212836983](C:\Users\57873\AppData\Roaming\Typora\typora-user-images\image-20231127212836983.png)

### 关键点：

求一个数的因子，只用求到它的根号+1即可。

### 解法1：

```python
def fun1():
    def is_prime(x):
        if x == 1:
            return False
        for _i in range(2, 1 + int(x ** 0.5)):
            if x % _i == 0:
                return False
        return True
    n = int(input())
    res = []
    i = 2
    while i < 1 + int(n ** 0.5):
        # 如果是因子，且是质数，则不断除以此数
        if n % i == 0:  # and is_prime(i):  # 由于n已经对比i小的所有数取余过了，所以如果能对i取余为0，则i必是质数
            while n % i == 0:
                n //= i
                res.append(str(i))
        i += 1
    if is_prime(n):
        res.append(str(n))
    print(' '.join(res))
```

### 解法

```python
def fun2():
    n = int(input())
    if 1 < n <= 3:
        print(n)
    i = 2
    while i < int(n ** 0.5) + 1:
        while n % i == 0:  # 由于n已经对比i小的所有数取余过了，所以如果能对i取余为0，则i必是质数
            n = n // i
            print(i, end=' ')
        i += 1
if n > 1:
    print(n)
```

